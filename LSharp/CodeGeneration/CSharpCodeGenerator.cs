using System;
using System.Collections.Generic;
using System.Text;
using Antlr4.Runtime.Misc;
using System.IO;
using System.Globalization;

namespace LSharp.CodeGeneration
{
    public class CSharpCodeGenerator : LSharpParserBaseVisitor<object>, IDisposable
    {
        private int tab = 0;
        private readonly string file = "test.ls";
        private string className = "";
        private readonly TextWriter output;

        public CSharpCodeGenerator()
        {
            output = new StreamWriter(Console.OpenStandardOutput())
            {
                AutoFlush = true
            };
        }

        public CSharpCodeGenerator(string file)
        {
            this.file = file;
            output = new StreamWriter(new FileStream(file, FileMode.Create))
            {
                AutoFlush = true
            };
        }

        /* General program structure. */

        public override object VisitProgram([NotNull] LSharpParser.ProgramContext context)
        {
            Genera($@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code has been generated by the LSharp Compiler (Version 1.0).
//     Source file name: {file.Replace(".cs", ".ls")}
//     Generation date: {DateTime.Now.ToString("dd-MMM-yyyy", CultureInfo.InvariantCulture)}
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------");
            Genera("");

            context.usingList().Accept(this);
            
            Genera("");
            /// namespace declaration
            // part of Namespace.Name
            if (context.@namespace() != null)
            {
                Genera(context.@namespace().Accept(this));
                Genera("{");
                tab++;
            }

            foreach(var member in context.langMember())
                member.Accept(this);

            if (context.@namespace() != null)
            {
                tab--;
                Genera("}");
            }

            return null;
        }

        public override object VisitUsing([NotNull] LSharpParser.UsingContext context)
        {
            Genera("using " + context.ident().Accept(this) + ";");

            return null;
        }

        public override object VisitInterfaceDef([NotNull] LSharpParser.InterfaceDefContext context)
        {
            Genera(context.access().Accept(this) + " interface " + context.ident().Accept(this));
            Genera("{");
            tab++;

            VisitChildren(context);

            tab--;
            Genera("}");

            return null;
        }

        public override object VisitClassDef([NotNull] LSharpParser.ClassDefContext context)
        {
            // Constructors do not carry their class' generic parameters
            className = context.ident().Accept(this).ToString().Split('<')[0];

            Genera(context.access().Accept(this) + (context.STATIC() != null ? " static" : "") 
                + " class " + context.ident().Accept(this) + (context.baseClass() != null ? context.baseClass().Accept(this) : ""));
            Genera("{");
            tab++;

            VisitChildren(context);

            tab--;
            Genera("}");

            return null;
        }

        /* Statements are written directly into the destination stream. */

        public override object VisitInterfaceMember([NotNull] LSharpParser.InterfaceMemberContext context)
        {
            Genera((context.VAR() != null ? "dynamic " : "void ") + context.ident().Accept(this) + "(" + context.@params().Accept(this) + ");");

            return null;
        }

        public override object VisitNonEndingStatement([NotNull] LSharpParser.NonEndingStatementContext context)
        {
            if (context.funcCall() != null)
            {
                if (context.QM() != null)
                {
                    Genera("try");
                    Genera("{");
                    tab++;
                }
                Genera(context.funcCall().Accept(this) + ";");
                if (context.QM() != null)
                {
                    tab--;
                    Genera("}");
                    Genera("catch(Exception e)");
                    Genera("{");
                    tab++;
                    Genera(context.ident() != null ? (context.ident().Accept(this) + "(e);") : "// Intentionally left empty");
                    tab--;
                    Genera("}");
                }
            }
            else
            {
                VisitChildren(context);
            }

            return null;
        }

        public override object VisitVarDef([NotNull] LSharpParser.VarDefContext context)
        {
            Genera((context.access().PUBLIC() != null ? "public " : context.access().INTERNAL() != null ? "internal " : "private ")
                + (context.STATIC() != null ? "static " : "")
                + "dynamic "
                + context.IDENT()
                + (context.expression() != null ? " = " + context.expression().Accept(this) : "")
                + ";");

            return null;
        }

        public override object VisitLocalDef([NotNull] LSharpParser.LocalDefContext context)
        {
            Genera("dynamic " + context.IDENT()
                + (context.expression() != null ? " = " + context.expression().Accept(this) : "")
                + ";");

            return null;
        }

        public override object VisitFuncDef([NotNull] LSharpParser.FuncDefContext context)
        {
            Genera("");
            /// Special case for Entry Point method
            if (context.ENTRYPOINT() != null)
            {
                Genera("public static void Main(string[] args)");
            }
            else
            {
                Genera((context.access().PUBLIC() != null ? "public " : context.access().INTERNAL() != null ? "internal " : "private ")
                    + (context.STATIC() != null ? "static " : "")
                    + (context.VAR() != null ? "dynamic " : "void ")
                    + context.ident()[0].Accept(this)
                    + "(" + context.@params().Accept(this) + ")");
            }
            Genera("{");
            tab++;

            /// Integrated try-catch
            if (context.QM() != null)
            {
                Genera("try");
                Genera("{");
                tab++;
            }

            foreach (var st in context.statement())
                st.Accept(this);

            if (context.QM() != null)
            {
                tab--;
                Genera("}");
                Genera("catch(Exception e)");
                Genera("{");
                tab++;
                if (context.ENTRYPOINT() == null)
                {
                    Genera(context.ident().Length > 1 && context.ident()[1] != null ? (context.ident()[1].Accept(this) + "(e);") : "// Intentionally left empty");
                }
                else
                {
                    Genera(context.ident().Length > 0 && context.ident()[0] != null ? (context.ident()[0].Accept(this) + "(e);") : "// Intentionally left empty");
                }
                tab--;
                Genera("}");
            }

            tab--;
            Genera("}");

            return null;
        }

        public override object VisitCtorDef([NotNull] LSharpParser.CtorDefContext context)
        {
            /// Static constructor/initializer
            if (context.STATIC() != null)
            {
                Genera("static " + className + "()");
            }
            /// Normal constructor
            else
            {
                Genera((context.access().PUBLIC() != null ? "public " : context.access().INTERNAL() != null ? "internal " : "private ")
                    + className
                    + "(" + context.@params().Accept(this) + ")");
            }
            Genera("{");
            tab++;

            /// Integrated try-catch
            if (context.QM() != null)
            {
                Genera("try");
                Genera("{");
                tab++;
            }

            foreach (var st in context.nonEndingStatement())
            {
                st.Accept(this);
            }

            if (context.QM() != null)
            {
                tab--;
                Genera("}");
                Genera("catch(Exception e)");
                Genera("{");
                tab++;
                Genera(context.ident() != null ? (context.ident().Accept(this) + "(e);") : "// Intentionally left empty");
                tab--;
                Genera("}");
            }

            tab--;
            Genera("}");

            return null;
        }

        public override object VisitAssign([NotNull] LSharpParser.AssignContext context)
        {
            Genera(context.ident().Accept(this) + " " + context.assignOperator().GetText() + " " + context.expression().Accept(this) + ";");

            return null;
        }

        public override object VisitTriStatement([NotNull] LSharpParser.TriStatementContext context)
        {
            Genera("if(" + context.expression().Accept(this) + ")");
            Genera("{");
            tab++;

            context.ifBlock().Accept(this);
            context.endingStatement()[0].Accept(this);

            tab--;
            Genera("}");
            if (context.elseBlock() != null)
            {
                Genera("else");
                Genera("{");
                tab++;

                context.elseBlock().Accept(this);
                context.endingStatement()[1].Accept(this);

                tab--;
                Genera("}");
            }

            return null;
        }

        public override object VisitWhileStatement([NotNull] LSharpParser.WhileStatementContext context)
        {
            Genera("while (" + context.expression().Accept(this) + ")");
            Genera("{");
            tab++;

            foreach (var st in context.nonEndingStatement())
            {
                st.Accept(this);
            }

            context.endingStatement().Accept(this);

            tab--;
            Genera("}");

            return null;
        }

        public override Object VisitForeachStatement([NotNull] LSharpParser.ForeachStatementContext context)
        {
            Genera("foreach (dynamic " + context.IDENT().GetText() + " in " + context.ident().Accept(this) + ")");
            Genera("{");
            tab++;

            foreach (var st in context.nonEndingStatement())
            {
                st.Accept(this);
            }

            context.endingStatement().Accept(this);

            tab--;
            Genera("}");

            return null;
        }
        
        public override object VisitSwitchStatement([NotNull] LSharpParser.SwitchStatementContext context)
        {
            /// Full switch (with or without default case)
            // expr ?? value: statement ?: statement
            if (context.caseBlock().Length > 0)
            {
                Genera("if (" + context.expression().Accept(this) + " == " + context.caseBlock()[0].expression().Accept(this) + ")");
                Genera("{");
                tab++;

                foreach (var st in context.caseBlock()[0].nonEndingStatement())
                {
                    st.Accept(this);
                }
                context.caseBlock()[0].endingStatement().Accept(this);

                tab--;
                Genera("}");

                for (int i = 1; i < context.caseBlock().Length; i++)
                {
                    Genera("else if (" + context.expression().Accept(this) + " == " + context.caseBlock()[i].expression().Accept(this) + ")");
                    Genera("{");
                    tab++;

                    foreach (var st in context.caseBlock()[i].nonEndingStatement())
                    {
                        st.Accept(this);
                    }
                    context.caseBlock()[i].endingStatement().Accept(this);

                    tab--;
                    Genera("}");
                }

                if (context.defaultBlock() != null)
                {
                    Genera("else");
                    Genera("{");
                    tab++;

                    foreach (var st in context.defaultBlock().nonEndingStatement())
                    {
                        st.Accept(this);
                    }
                    context.defaultBlock().endingStatement().Accept(this);

                    tab--;
                    Genera("}");
                }

                return null;
            }

            /// Switch with default case only
            // expr ?? ?: statement
            if (context.caseBlock().Length == 0 && context.defaultBlock() != null)
            {
                foreach (var st in context.defaultBlock().nonEndingStatement())
                {
                    st.Accept(this);
                }
                context.defaultBlock().endingStatement().Accept(this);

                return null;
            }

            /// Empty switch (ignored)
            // expr ??
            if (context.caseBlock().Length == 0 && context.defaultBlock() == null)
            {
                return null;
            }

            return null;
        }

        public override object VisitIfBlock([NotNull] LSharpParser.IfBlockContext context)
        {
            foreach (var st in context.nonEndingStatement())
            {
                st.Accept(this);
            }

            return null;
        }

        public override object VisitElseBlock([NotNull] LSharpParser.ElseBlockContext context)
        {
            foreach (var st in context.nonEndingStatement())
            {
                st.Accept(this);
            }

            return null;
        }

        public override object VisitReturnStatement([NotNull] LSharpParser.ReturnStatementContext context)
        {
            Genera("return" + (context.expression() != null ? " " + context.expression().Accept(this) : "") + ";");

            return null;
        }

        public override object VisitThrowStatement([NotNull] LSharpParser.ThrowStatementContext context)
        {
            Genera("throw " + context.ident().Accept(this) + ";");

            return null;
        }

        public override object VisitEmptyStatement([NotNull] LSharpParser.EmptyStatementContext context)
        {
            Genera(";");

            return null;
        }

        public override object VisitNullCheck([NotNull] LSharpParser.NullCheckContext context)
        {
            /// Check whether expression is not null
            // expr ?: statement
            if (context.DEF() != null)
            {
                Genera("if (" + context.expression().Accept(this) + " != null)");
                Genera("{");
                tab++;

                foreach (var st in context.nonEndingStatement())
                {
                    st.Accept(this);
                }
                context.endingStatement().Accept(this);

                tab--;
                Genera("}");
            }
            /// Check whether expression is null
            // expr !: statement
            if (context.NIL() != null)
            {
                Genera("if (" + context.expression().Accept(this) + " == null)");
                Genera("{");
                tab++;

                foreach (var st in context.nonEndingStatement())
                {
                    st.Accept(this);
                }
                context.endingStatement().Accept(this);

                tab--;
                Genera("}");
            }

            return null;
        }

        /* Expressions are returned to be embedded into a statement. */

        public override object VisitNamespace([NotNull] LSharpParser.NamespaceContext context)
        {
            return "namespace " + context.ident().Accept(this);
        }

        public override object VisitBaseClass([NotNull] LSharpParser.BaseClassContext context)
        {
            StringBuilder sb = new StringBuilder(" : ");

            foreach (var param in context.ident())
            {
                sb.Append(param.Accept(this) + ", ");
            }

            sb.Remove(sb.Length - 2, 2);

            return sb.ToString();
        }

        public override object VisitAccess([NotNull] LSharpParser.AccessContext context) => context.GetText();

        public override object VisitIdent([NotNull] LSharpParser.IdentContext context)
        {
            /// ident.ident
            if (context.DOT() != null)
            {
                return context.ident()[0].Accept(this) + "." + context.ident()[1].Accept(this);
            }
            /// ident[expression]
            if (context.OSB() != null)
            {
                return context.ident()[0].Accept(this) + "[" + context.expression().Accept(this) + "]";
            }
            /// ident<ident>
            if (context.LT() != null)
            {
                var res = context.ident()[0].Accept(this) + "<";
                res += context.ident()[1].Accept(this);

                for (int i = 2; i < context.ident().Length; i++)
                {
                    res += ", " + context.ident()[i].Accept(this);
                }

                res += ">";

                return res;
            }
            /// new ident()
            if (context.NEW() != null)
            {
                return "new " + context.funcCall().Accept(this);
            }

            return context.GetText();
        }

        public override object VisitExpression([NotNull] LSharpParser.ExpressionContext context)
        {
            return context.ident() != null ? context.ident().Accept(this) :
                context.LITINT() != null ? context.LITINT().ToString() :
                context.LITDEC() != null ? context.LITDEC().ToString() :
                context.LITCHAR() != null ? context.LITCHAR().ToString() :
                context.LITSTR() != null ? context.LITSTR().ToString() :
                context.LITBOOL() != null ? context.LITBOOL().ToString() :
                context.NULL() != null ? "null" :
                context.funcCall() != null ? VisitFuncCall(context.funcCall()) :
                context.binaryOp() != null ? context.expression()[0].Accept(this) + " " + context.binaryOp().GetText() + " " + context.expression()[1].Accept(this) :
                context.EM() != null ? "!" + context.expression()[0].Accept(this) :
                context.OP() != null ? "(" + context.expression()[0].Accept(this) + ")" :
                context.expression()[0].Accept(this) + " ? " + context.expression()[1].Accept(this) + " : " + context.expression()[2].Accept(this);
        }

        public override object VisitParams([NotNull] LSharpParser.ParamsContext context)
        {
            if (context.ident().Length == 0)
            {
                return "";
            }

            StringBuilder sb = new StringBuilder();
            foreach (var param in context.ident())
            {
                sb.Append("dynamic " + param.Accept(this) + ", ");
            }

            sb.Remove(sb.Length - 2, 2);

            return sb.ToString();
        }

        public override object VisitArgs([NotNull] LSharpParser.ArgsContext context)
        {
            if (context.expression().Length == 0)
            {
                return "";
            }

            StringBuilder sb = new StringBuilder();
            foreach (var param in context.expression())
            {
                sb.Append(param.Accept(this) + ", ");
            }

            sb.Remove(sb.Length - 2, 2);

            return sb.ToString();
        }

        public override object VisitFuncCall([NotNull] LSharpParser.FuncCallContext context)
        {
            return context.ident().Accept(this) + "(" + context.args().Accept(this) + ")";
        }



        private void Genera(string code)
        {
            for (int i = 0; i < tab; i++)
            {
                output.Write("\t");
            }
            output.WriteLine(code);
        }

        private void Genera(object code) => Genera(code.ToString());


        public void Dispose() => output.Dispose();
    }
}
